#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.99999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.995                     # ← change to 0.995 or 0.975 if you prefer
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
View(daily_cd)
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.9999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.9999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.99999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.99995                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.9999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
View(daily_cd)
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.999                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
#  Reads output/daily_rats_by_cd_checked.csv   (or daily_rats_by_cd.csv)
#  Caps the 'calls' field at the 99th-percentile (adjustable)
#  Writes output/daily_rats_by_cd_win.csv
#
#  In Tableau:
#     Use  calls_capped  for colour / table-calcs
#     Keep  calls        in tooltips so the 229 spike is still visible
library(dplyr)
library(readr)
# ── 1) Read -------------------------------------------------------------------
daily_cd <- read_csv("output/daily_rats_by_cd.csv",
show_col_types = FALSE)
# ── 2) Choose a threshold -----------------------------------------------------
P <- 0.99                     # ← change to 0.995 or 0.975 if you prefer
cap_val <- quantile(daily_cd$calls, P, na.rm = TRUE)
message("Winsorising at the ", P*100, "th percentile: cap = ", cap_val)
# ── 3) Add capped column ------------------------------------------------------
daily_cd <- daily_cd %>%
mutate(
calls_capped = pmin(calls, cap_val),
capped_flag  = calls > cap_val       # TRUE if the original was trimmed
)
# ── 4) Write out --------------------------------------------------------------
write_csv(daily_cd, "output/daily_rats_by_cd_win.csv")
message("✅ Wrote winsorised daily counts to output/daily_rats_by_cd_win.csv")
# Build a tract-level table pairing rat-call rates with median household income,
# plus bins, indexes, labels—and ready-to-use fields for Tableau.
#
# Output: output/income_scatter_prepped.csv
## 0) Libraries ---------------------------------------------------------------
# install.packages(c("sf","dplyr","readr","stringr","DescTools","scales"))
library(sf)
library(dplyr)
library(stringr)
library(readr)
library(DescTools)
# Build a tract-level table pairing rat-call rates with median household income,
# plus bins, indexes, labels—and ready-to-use fields for Tableau.
#
# Output: output/income_scatter.csv
## 0) Libraries ---------------------------------------------------------------
install.packages(c("sf","dplyr","readr","stringr","DescTools","scales"))
library(sf)
library(dplyr)
library(stringr)
library(readr)
library(DescTools)
# Build a tract-level table pairing rat-call rates with median household income,
# plus bins, indexes, labels—and ready-to-use fields for Tableau.
#
# Output: output/income_scatter.csv
## 0) Libraries ---------------------------------------------------------------
# install.packages(c("sf","dplyr","readr","stringr","DescTools","scales"))
library(sf)
library(dplyr)
library(stringr)
library(readr)
library(DescTools)
library(scales)
## 1) Read enriched points & drop geometry -----------------------------------
rats_enriched <- st_read(
"output/rats_enriched.geojson",
geometry_column = NA,
quiet = TRUE
)
# 023_income_scatter_prepped.R
# --------------------------------------------------------------
# Build a tract-level table pairing rat-call rates with median household income,
# plus bins, indexes, labels—and ready-to-use fields for Tableau.
#
# Output: output/income_scatter_prepped.csv
## 0) Libraries ---------------------------------------------------------------
# install.packages(c("sf","dplyr","readr","stringr","DescTools","scales"))
library(sf)
library(dplyr)
library(stringr)
library(readr)
library(DescTools)
library(scales)
## 1) Read enriched points & drop geometry -----------------------------------
rats_enriched <- st_read(
"output/rats_enriched.geojson",
quiet = TRUE
) %>%
st_drop_geometry()
stopifnot(!any(is.na(rats_enriched$GEOID)))  # ensure every record has a tract ID
View(rats_enriched)
View(rat_enriched)
View(income_scatter_df)
View(rats_enriched)
View(calls_by_tract)
# 023_income_scatter_prepped.R
# --------------------------------------------------------------
# Build a tract-level table pairing rat-call rates with median household income,
# plus bins, indexes, labels—and ready-to-use fields for Tableau.
#
# Output: output/income_scatter_prepped.csv
## 0) Libraries ---------------------------------------------------------------
# install.packages(c("sf","dplyr","readr","stringr","DescTools","scales"))
library(sf)
library(dplyr)
library(stringr)
library(readr)
library(DescTools)
library(scales)
## 1) Read enriched points & drop geometry -----------------------------------
rats_enriched <- st_read(
"output/rats_enriched.geojson",
quiet = TRUE
) %>%
st_drop_geometry()
stopifnot(!any(is.na(rats_enriched$GEOID)))  # ensure every record has a tract ID
# 023_income_scatter_prepped.R
# --------------------------------------------------------------
# Build a tract-level table pairing rat-call rates with median household income,
# plus bins, indexes, labels—and ready-to-use fields for Tableau.
#
# Output: output/income_scatter_prepped.csv
## 0) Libraries ---------------------------------------------------------------
# install.packages(c("sf","dplyr","readr","stringr","DescTools","scales"))
library(sf)
library(dplyr)
library(stringr)
library(readr)
library(DescTools)
library(scales)
## 1) Read enriched points & drop geometry -----------------------------------
rats_enriched <- st_read(
"output/rats_enriched.geojson",
quiet = TRUE
) %>%
st_drop_geometry()
## 2) Count distinct calls per tract -----------------------------------------
calls_by_tract <- rats_enriched %>%
transmute(
tract_id   = str_sub(GEOID, 1, 11),
Unique_Key
) %>%
distinct() %>%
count(tract_id, name = "calls")
names(rats_enriched)
## 2) Count distinct calls per tract -----------------------------------------
calls_by_tract <- rats_enriched %>%
transmute(
tract_id   = str_sub(GEOID, 1, 11),
Unique.Key
) %>%
distinct() %>%
count(tract_id, name = "calls")
## 3) Read ACS block-group data ------------------------------------------------
acs_bg <- read_csv("data/processed/ACS.csv", show_col_types = FALSE) %>%
select(GEOID, pop_tot, med_income)
## 4) Aggregate ACS from BG → tract ------------------------------------------
tract_acs <- acs_bg %>%
mutate(tract_id = str_sub(GEOID, 1, 11)) %>%
group_by(tract_id) %>%
summarise(
median_income = WeightedMedian(med_income, w = pop_tot, na.rm = TRUE),
pop_tot       = sum(pop_tot, na.rm = TRUE),
.groups       = "drop"
)
library(matrixStats)
## 2) Count distinct calls per tract -----------------------------------------
calls_by_tract <- rats_enriched %>%
transmute(
tract_id   = str_sub(GEOID, 1, 11),
Unique.Key
) %>%
distinct() %>%
count(tract_id, name = "calls")
# Build a tract‑level table that pairs rat‑call rates with median household
# income – exactly what the Tableau scatter plot needs.
#
# Steps
#   1. Read the fully enriched rat GeoJSON (has GEOID + PLUTO + ACS columns).
#   2. Count calls per *tract* (first 11 chars of the 12‑digit GEOID).
#   3. Load the BBL‑keyed ACS lookup and roll it up from BG → tract.
#   4. Join calls + income, compute calls‑per‑10k residents.
#   5. Write a slim CSV for Tableau.
# -----------------------------------------------------------------------------
## 0) Libraries ----------------------------------------------------------------
# install.packages(c("sf", "dplyr", "readr", "stringr"))
library(sf)
library(dplyr)
library(readr)
library(stringr)
## 1) Read rat sightings with GEOID -------------------------------------------
#    Note: earlier script writes *rats_enriched.geojson* – make sure the path
#    matches. If not, adjust the filename below.
rats_enriched <- st_read("output/rats_enriched.geojson", quiet = TRUE)
## 2) Calls per tract -----------------------------------------------------------
calls_by_tract <- rats_enriched %>%
mutate(
tract = str_sub(GEOID, 1, 11)  # GEOID[1:11] = state + county + tract
) %>%
st_drop_geometry() %>%           # stats only; no need for shapes
count(tract, name = "calls")
df <- readr::read_csv("output/income_scatter.csv")
glimpse(df)
summary(df$rate_per_10k)
df <- readr::read_csv("output/income_scatter.csv")
df %>%
arrange(desc(rate_per_10k)) %>%
slice(1:5) %>%
print()
gc()
gc()
# Master driver that runs the entire rat‑data pipeline **in order** and checks
# that every expected artefact is created. Handy for fresh environments or CI.
#
# Outline
# 0. (Optional) setwd() to the repo root.
# 1. Define the ordered vector of R scripts to source.
# 2. Loop through and `source()` each, echoing output.
# 3. Assert that the key CSV / GeoJSON files exist.
# ---------------------------------------------------------------------------
## 0) Working directory -------------------------------------------------------
# Uncomment and edit if you intend to run this outside the project root.
# setwd("C:/path/to/nyc-rat-abundance")
## 1) Scripts to run (ordered) -------------------------------------------------
scripts <- c(
"scripts/000_setup_cmdstanr.R",
"scripts/011_data_prep.R",
"scripts/012_data_prep_derivation.R",  # makes rats_ready + borough_rates
"scripts/021_acs_fetch.R",             # BBL‑keyed ACS lookup
"scripts/022_spatial_join.R",          # adds PLUTO & ACS to rat points
"scripts/023_income_scatter.R",        # tract‑level scatter data
"scripts/024_bg_acs_join.R"            # BG‑level join & summary
)
## 2) Run each script, stop on error -----------------------------------------
for (s in scripts) {
message("🔄  Running ", s, " …")
source(s, echo = TRUE)
}
install.packages(c("vroom", "dplyr", "stringr", "lubridate", "readr", "rstudioapi"))
View(boro_pop)
gc()
