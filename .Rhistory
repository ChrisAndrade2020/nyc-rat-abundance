if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
# point to the Stan-maintained CRAN-like repo first
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the cmdstanr package into this R session
#    This gives us access to its functions like install_cmdstan()
library(cmdstanr)
# 3. Verify that Rtools (the C++ compiler) and Make are on your PATH
#    check_cmdstan_toolchain() prints ✓ checks if everything’s OK,
#    or tells you what’s missing if not.
cmdstanr::check_cmdstan_toolchain(fix = FALSE)
# 4. Download & compile the CmdStan C++ code if it’s not already present
#    overwrite = FALSE skips rebuilding if cmdstan-<version>/ exists.
cmdstanr::install_cmdstan(overwrite = FALSE)
# 5. Locate the built-in Bernoulli example Stan program
#    We use file.path() + cmdstan_path() so this works on any OS.
stan_file <- file.path(
cmdstanr::cmdstan_path(),
"examples", "bernoulli", "bernoulli.stan"
)
# 6. Compile that .stan file into an executable
#    cmdstan_model() checks the timestamp and only recompiles if needed.
mod <- cmdstanr::cmdstan_model(stan_file)
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Purpose: install and verify the Stan toolchain (CmdStanR + Rtools) on Windows
# 1. If cmdstanr isn’t already installed, fetch it from the Stan repo
#    We wrap in requireNamespace() so we don’t reinstall on every run.
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
# point to the Stan-maintained CRAN-like repo first
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the cmdstanr package into this R session
#    This gives us access to its functions like install_cmdstan()
library(cmdstanr)
# 3. Verify that Rtools (the C++ compiler) and Make are on your PATH
#    check_cmdstan_toolchain() prints ✓ checks if everything’s OK,
#    or tells you what’s missing if not.
cmdstanr::check_cmdstan_toolchain(fix = FALSE)
# 4. Download & compile the CmdStan C++ code if it’s not already present
#    overwrite = FALSE skips rebuilding if cmdstan-<version>/ exists.
cmdstanr::install_cmdstan(overwrite = FALSE)
# 5. Locate the built-in Bernoulli example Stan program
#    We use file.path() + cmdstan_path() so this works on any OS.
stan_file <- file.path(
cmdstanr::cmdstan_path(),
"examples", "bernoulli", "bernoulli.stan"
)
# 6. Compile that .stan file into an executable
#    cmdstan_model() checks the timestamp and only recompiles if needed.
mod <- cmdstanr::cmdstan_model(stan_file)
# 7. Define tiny dummy data matching the Stan program’s 'data' block
data_list <- list(
N = 8,                     # number of observations
y = c(1, 0, 1, 1, 0, 0, 1, 0)  # example successes/failures
)
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Purpose: install and verify the Stan toolchain (CmdStanR + Rtools) on Windows
# 1. If cmdstanr isn’t already installed, fetch it from the Stan repo
#    We wrap in requireNamespace() so we don’t reinstall on every run.
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
# point to the Stan-maintained CRAN-like repo first
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the cmdstanr package into this R session
#    This gives us access to its functions like install_cmdstan()
library(cmdstanr)
# 3. Verify that Rtools (the C++ compiler) and Make are on your PATH
#    check_cmdstan_toolchain() prints ✓ checks if everything’s OK,
#    or tells you what’s missing if not.
cmdstanr::check_cmdstan_toolchain(fix = FALSE)
# 4. Download & compile the CmdStan C++ code if it’s not already present
#    overwrite = FALSE skips rebuilding if cmdstan-<version>/ exists.
cmdstanr::install_cmdstan(overwrite = FALSE)
# 5. Locate the built-in Bernoulli example Stan program
#    We use file.path() + cmdstan_path() so this works on any OS.
stan_file <- file.path(
cmdstanr::cmdstan_path(),
"examples", "bernoulli", "bernoulli.stan"
)
# 6. Compile that .stan file into an executable
#    cmdstan_model() checks the timestamp and only recompiles if needed.
mod <- cmdstanr::cmdstan_model(stan_file)
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Purpose: install and verify the Stan toolchain (CmdStanR + Rtools) on Windows
# 1. If cmdstanr isn’t already installed, fetch it from the Stan repo
#    We wrap in requireNamespace() so we don’t reinstall on every run.
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
# point to the Stan-maintained CRAN-like repo first
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the cmdstanr package into this R session
#    This gives us access to its functions like install_cmdstan()
library(cmdstanr)
# 3. Verify that Rtools (the C++ compiler) and Make are on your PATH
#    check_cmdstan_toolchain() prints ✓ checks if everything’s OK,
#    or tells you what’s missing if not.
cmdstanr::check_cmdstan_toolchain(fix = FALSE)
# 4. Download & compile the CmdStan C++ code if it’s not already present
#    overwrite = FALSE skips rebuilding if cmdstan-<version>/ exists.
cmdstanr::install_cmdstan(overwrite = FALSE)
# 5. Locate the built-in Bernoulli example Stan program
#    We use file.path() + cmdstan_path() so this works on any OS.
stan_file <- file.path(
cmdstanr::cmdstan_path(),
"examples", "bernoulli", "bernoulli.stan"
)
# 6. Compile that .stan file into an executable
#    cmdstan_model() checks the timestamp and only recompiles if needed.
mod <- cmdstanr::cmdstan_model(stan_file)
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Purpose: install and verify the Stan toolchain (CmdStanR + Rtools) on Windows
# 1. If cmdstanr isn’t already installed, fetch it from the Stan repo
#    We wrap in requireNamespace() so we don’t reinstall on every run.
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
# point to the Stan-maintained CRAN-like repo first
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the cmdstanr package into this R session
#    This gives us access to its functions like install_cmdstan()
library(cmdstanr)
# 3. Verify that Rtools (the C++ compiler) and Make are on your PATH
#    check_cmdstan_toolchain() prints ✓ checks if everything’s OK,
#    or tells you what’s missing if not.
cmdstanr::check_cmdstan_toolchain(fix = FALSE)
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Purpose: install and verify the Stan toolchain (CmdStanR + Rtools) on Windows
# 1. If cmdstanr isn’t already installed, fetch it from the Stan repo
#    We wrap in requireNamespace() so we don’t reinstall on every run.
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
# point to the Stan-maintained CRAN-like repo first
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the cmdstanr package into this R session
#    This gives us access to its functions like install_cmdstan()
library(cmdstanr)
# 3. Verify that Rtools (the C++ compiler) and Make are on your PATH
#    check_cmdstan_toolchain() prints ✓ checks if everything’s OK,
#    or tells you what’s missing if not.
cmdstanr::check_cmdstan_toolchain(fix = TRUE)
# 4. Download & compile the CmdStan C++ code if it’s not already present
#    overwrite = FALSE skips rebuilding if cmdstan-<version>/ exists.
cmdstanr::install_cmdstan(overwrite = FALSE)
# 5. Locate the built-in Bernoulli example Stan program
#    We use file.path() + cmdstan_path() so this works on any OS.
stan_file <- file.path(
cmdstanr::cmdstan_path(),
"examples", "bernoulli", "bernoulli.stan"
)
# 6. Compile that .stan file into an executable
#    cmdstan_model() checks the timestamp and only recompiles if needed.
mod <- cmdstanr::cmdstan_model(stan_file)
The filename, directory name, or volume label syntax is incorrect.cmdstanr::check_cmdstan_toolchain(fix = TRUE)
cmdstanr::check_cmdstan_toolchain(fix = TRUE)
# 00_setup_cmdstanr.R
# -------------------
# Installs and verifies CmdStanR + Rtools toolchain on Windows
# 1. Install cmdstanr (from the Stan R-packages repo)
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load cmdstanr
library(cmdstanr)
# 3. Check that Rtools (and other compilers) are on PATH
#    Fix = FALSE will only report issues; set to TRUE to auto-attempt fixes
check_cmdstan_toolchain(fix = FALSE)
# 4. Install CmdStan itself (downloads ≈1 GB, compiles C++ toolchain)
install_cmdstan()
# 5. Run a tiny example model to confirm everything works
fit <- example_model()      # compiles & samples a demo Stan model
# 00_setup_cmdstanr.R
# -------------------
# Installs and verifies CmdStanR + Rtools toolchain on Windows
# 1. Install cmdstanr (if missing)
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the package
library(cmdstanr)
# 3. Check that your C++ toolchain (Rtools) & CmdStan are available
cmdstanr::check_cmdstan_toolchain(fix = FALSE)  # should print green ✓s :contentReference[oaicite:0]{index=0}
# 4. Install CmdStan itself (≈1 GB; may take 10–15 min)
cmdstanr::install_cmdstan()                     # downloads & compiles CmdStan :contentReference[oaicite:1]{index=1}
# 5. Compile & sample the Bernoulli example to confirm everything works
stan_file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod        <- cmdstan_model(stan_file)          # compile the .stan file
# 00_setup_cmdstanr.R
# -------------------
# Installs and verifies CmdStanR + Rtools toolchain on Windows
# 1. Install cmdstanr (if missing)
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load the package
library(cmdstanr)
# 3. Check that your C++ toolchain (Rtools) & CmdStan are available
cmdstanr::check_cmdstan_toolchain(fix = FALSE)  # should print green ✓s :contentReference[oaicite:0]{index=0}
# 4. Install CmdStan itself (≈1 GB; may take 10–15 min)
cmdstanr::install_cmdstan()                     # downloads & compiles CmdStan :contentReference[oaicite:1]{index=1}
# 5. Compile & sample the Bernoulli example to confirm everything works
stan_file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod        <- cmdstan_model(stan_file)          # compile the .stan file
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Installs and verifies CmdStanR + Rtools toolchain on Windows
# 1. Install cmdstanr if missing
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
}
# 2. Load cmdstanr
library(cmdstanr)
# 3. Check that Rtools + C++ toolchain are on PATH
cmdstanr::check_cmdstan_toolchain(fix = FALSE)
# 4. Install CmdStan itself (≈1 GB; safe to re‐run, won’t duplicate)
cmdstanr::install_cmdstan(overwrite = FALSE)
# 5. Compile the built-in Bernoulli example
stan_file <- file.path(cmdstanr::cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod       <- cmdstanr::cmdstan_model(stan_file)
# scripts/00_setup_cmdstanr.R
# ----------------------------
# Fresh start: Install & verify CmdStanR + Rtools toolchain on Windows
# ---- 1) Install or update cmdstanr package ----
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
install.packages(
"cmdstanr",
repos = c("https://mc-stan.org/r-packages/", getOption("repos"))
)
} else {
message("✔ cmdstanr package is already installed")
}
# ---- 2) Load cmdstanr into this session ----
library(cmdstanr)
# ---- 3) Check C++ toolchain (Rtools) & Make ----
#    fix=TRUE will attempt to configure missing bits automatically
cmdstanr::check_cmdstan_toolchain(fix = TRUE)
# ---- 4) Install CmdStan itself (≈1 GB; safe to re-run) ----
#    overwrite=FALSE skips if already present; set to TRUE to force reinstall
cmdstanr::install_cmdstan(overwrite = FALSE)
# ---- 5) Compile the built-in Bernoulli example ----
stan_file <- file.path(
cmdstanr::cmdstan_path(),
"examples", "bernoulli", "bernoulli.stan"
)
mod <- cmdstanr::cmdstan_model(stan_file)
.Last.error
install.packages("usethis")       # if you don’t already have it
usethis::edit_r_environ()         # opens your ~/.Renviron in the editor
# scripts/01_data_prep.R
# ----------------------
# Day 1 – Data Prep: preview a small sample, then load & filter the full ~912K rows
# 0) Load libraries (run once)
install.packages(c("vroom", "dplyr", "stringr", "lubridate"))
library(vroom)
library(dplyr)
library(stringr)
library(lubridate)
# 1) Define path to the raw 311 CSV
data_path <- "data/raw/311_Service_Requests_from_2010_to_Present_20250526.csv"
# 2) Preview a sample of 5,000 rows
rats_sample <- vroom(
file       = data_path,
n_max      = 5000,
col_select = c(
"Unique Key",
"Created Date",
"Closed Date",
"Status",
"Location Type",
"Incident Zip",
"Borough",
"BBL",
"Latitude",
"Longitude",
"Descriptor"
)
)
# Inspect the sample
print(head(rats_sample, 5))
print(names(rats_sample))
# 3) Now load & clean the full dataset (~912K rows) into rats_sample
rats_sample <- vroom(
file       = data_path,
col_select = c(
"Unique Key",
"Created Date",
"Closed Date",
"Status",
"Location Type",
"Incident Zip",
"Borough",
"BBL",
"Latitude",
"Longitude",
"Descriptor"
),
col_types = cols(
`Unique Key`      = col_character(),
`Created Date`    = col_datetime(),   # now a POSIXct
`Closed Date`     = col_datetime(),   # now a POSIXct
Status            = col_character(),
`Location Type`   = col_character(),
`Incident Zip`    = col_character(),
Borough           = col_character(),
BBL               = col_character(),
Latitude          = col_double(),
Longitude         = col_double(),
Descriptor        = col_character()
)
) %>%
# 3a) Rename the parsed dates and compute days_open
mutate(
created_dt = `Created Date`,                     # already POSIXct
closed_dt  = `Closed Date`,
days_open  = as.numeric(closed_dt - created_dt, units = "days")
) %>%
select(-`Created Date`, -`Closed Date`, -Status) %>%  # drop raw cols
# 3b) Filter to only rodent‐related reports
filter(
str_starts(Descriptor, regex("Rat|Rodent|Mouse", ignore_case = TRUE)) |
str_detect(Descriptor,     regex("dropp|burrow|bait|nest|runway|gnaw", ignore_case = TRUE))
)
# 4) Report how many rows and check the new columns
message("✅ Loaded & cleaned: ", nrow(rats_sample), " rows")
glimpse(rats_sample)  # you should now see created_dt and days_open populated
View(rats_sample)
# scripts/01_data_prep.R
# ----------------------
# Day 1 – Data Prep: preview a small sample, then load & filter the full ~912K rows
# 0) Load libraries (run once)
install.packages(c("vroom", "dplyr", "stringr", "lubridate"))
library(vroom)
library(dplyr)
library(stringr)
library(lubridate)
# 1) Define path to the raw 311 CSV
data_path <- "data/raw/311_Service_Requests_from_2010_to_Present_20250526.csv"
# 2) Preview a sample of 5,000 rows
rats_sample <- vroom(
file       = data_path,
n_max      = 5000,
col_select = c(
"Unique Key",
"Created Date",
"Closed Date",
"Status",
"Location Type",
"Incident Zip",
"Borough",
"BBL",
"Latitude",
"Longitude",
"Descriptor"
)
)
# Inspect the sample
print(head(rats_sample, 5))
print(names(rats_sample))
# 3) Load & clean all ~912K rows into rats_sample, parsing dates explicitly
rats_sample <- vroom(
file       = data_path,
col_select = c(
"Unique Key",
"Created Date",
"Closed Date",
"Status",
"Location Type",
"Incident Zip",
"Borough",
"BBL",
"Latitude",
"Longitude",
"Descriptor"
),
col_types = cols(
`Unique Key`      = col_character(),
`Created Date`    = col_character(),  # read as text
`Closed Date`     = col_character(),  # read as text
Status            = col_character(),
`Location Type`   = col_character(),
`Incident Zip`    = col_character(),
Borough           = col_character(),
BBL               = col_character(),
Latitude          = col_double(),
Longitude         = col_double(),
Descriptor        = col_character()
)
) %>%
# 3a) Parse dates with lubridate, compute days_open, drop raw fields
mutate(
created_dt = ymd_hms(`Created Date`),   # now true POSIXct
closed_dt  = ymd_hms(`Closed Date`),
days_open  = as.numeric(closed_dt - created_dt, units = "days")
) %>%
select(-`Created Date`, -`Closed Date`, -Status) %>%
# 3b) Filter to rodent-related entries
filter(
str_starts(Descriptor, regex("Rat|Rodent|Mouse", ignore_case = TRUE)) |
str_detect(Descriptor,     regex("dropp|burrow|bait|nest|runway|gnaw", ignore_case = TRUE))
)
# 4) Quick check
message("✅ Loaded & cleaned: ", nrow(rats_sample), " rows")
# scripts/01_data_prep.R
# ----------------------
# Day 1 – Data Prep: preview a small sample, then load & filter the full ~912K rows
# 0) Load libraries (run once)
install.packages(c("vroom", "dplyr", "stringr", "lubridate"))
library(vroom)
library(dplyr)
library(stringr)
library(lubridate)
# 1) Define path to the raw 311 CSV
data_path <- "data/raw/311_Service_Requests_from_2010_to_Present_20250526.csv"
# 2) Preview a sample of 5,000 rows
rats_sample <- vroom(
file       = data_path,
n_max      = 5000,
col_select = c(
"Unique Key",
"Created Date",
"Closed Date",
"Status",
"Location Type",
"Incident Zip",
"Borough",
"BBL",
"Latitude",
"Longitude",
"Descriptor"
)
)
# Inspect the sample
print(head(rats_sample, 5))
print(names(rats_sample))
# 3) Load & clean all ~912K rows into rats_sample, parsing dates explicitly
rats_sample <- vroom(
file       = data_path,
col_select = c(
"Unique Key",
"Created Date",
"Closed Date",
"Status",
"Location Type",
"Incident Zip",
"Borough",
"BBL",
"Latitude",
"Longitude",
"Descriptor"
),
col_types = cols(
`Unique Key`      = col_character(),
`Created Date`    = col_character(),  # read as text
`Closed Date`     = col_character(),  # read as text
Status            = col_character(),
`Location Type`   = col_character(),
`Incident Zip`    = col_character(),
Borough           = col_character(),
BBL               = col_character(),
Latitude          = col_double(),
Longitude         = col_double(),
Descriptor        = col_character()
)
) %>%
# 3a) Parse dates with lubridate, compute days_open, drop raw fields
mutate(
created_dt = ymd_hms(`Created Date`),   # now true POSIXct
closed_dt  = ymd_hms(`Closed Date`),
days_open  = as.numeric(closed_dt - created_dt, units = "days")
) %>%
select(-`Created Date`, -`Closed Date`, -Status) %>%
# 3b) Filter to rodent-related entries
filter(
str_starts(Descriptor, regex("Rat|Rodent|Mouse", ignore_case = TRUE)) |
str_detect(Descriptor,     regex("dropp|burrow|bait|nest|runway|gnaw", ignore_case = TRUE))
)
# 4) Quick check
message("✅ Loaded & cleaned: ", nrow(rats_sample), " rows")
glimpse(rats_sample)  # you should now see non-NA created_dt and days_open
